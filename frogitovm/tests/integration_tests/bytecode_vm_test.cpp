#include <array>
#include <atomic>
#include <cstdint>
#include <filesystem>
#include <fstream>
#include <string>
#include <system_error>
#include <stdexcept>

#include <gtest/gtest.h>

#include "bytecode/bytecode_loader.h"
#include "bytecode/bytecode_module.h"
#include "vm/vm.h"

namespace {

std::filesystem::path TempPath() {
    static std::atomic<std::uint64_t> counter{0};
    std::filesystem::path dir = std::filesystem::temp_directory_path();
    std::string name = "frogvm_" + std::to_string(counter.fetch_add(1, std::memory_order_relaxed)) + ".frogc";
    return dir / name;
}

template <std::size_t N>
BytecodeModule LoadModuleFromBytes(const std::array<std::uint8_t, N>& data) {
    std::filesystem::path tmp = TempPath();
    {
        std::ofstream out(tmp, std::ios::binary);
        if (!out) {
            throw std::runtime_error("failed to open temp file for writing");
        }
        out.write(reinterpret_cast<const char*>(data.data()),
                  static_cast<std::streamsize>(data.size()));
    }
    BytecodeModule module = load_frogc(tmp);
    std::error_code ec;
    std::filesystem::remove(tmp, ec);
    return module;
}

void ExpectGlobalInt(const Vm& vm, const std::string& name, std::int64_t expected) {
    auto globals = vm.globals();
    auto it = globals.find(name);
    ASSERT_NE(it, globals.end());
    std::int64_t got = 0;
    ASSERT_TRUE(it->second.AsInt().TryToInt64(got));
    EXPECT_EQ(got, expected);
}

void ExpectGlobalBool(const Vm& vm, const std::string& name, bool expected) {
    auto globals = vm.globals();
    auto it = globals.find(name);
    ASSERT_NE(it, globals.end());
    EXPECT_EQ(it->second.AsBool(), expected);
}

constexpr std::array<std::uint8_t, 41> kConstantArithmeticChain = {
    0x46, 0x52, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01, 0x78,
    0x01, 0x00, 0x00, 0x00, 0x46, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04,
    0x01, 0x00, 0x00, 0x00, 0x00,
};

constexpr std::array<std::uint8_t, 67> kConstantArithmeticPrecedence = {
    0x46, 0x52, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0x00, 0x00, 0x00, 0x01, 0x79,
    0x01, 0x00, 0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00,
    0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05,
    0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
};

constexpr std::array<std::uint8_t, 54> kConstantComparison = {
    0x46, 0x52, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00, 0x01, 0x62,
    0x01, 0x00, 0x00, 0x00, 0x0A, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x0F, 0x00,
    0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
};

constexpr std::array<std::uint8_t, 65> kArrayLiteral = {
    0x46, 0x52, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x04, 0x00, 0x00, 0x00, 0x04, 0x6E,
    0x75, 0x6D, 0x73, 0x01, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x18, 0x02, 0x00, 0x03, 0x04,
    0x01, 0x00, 0x00, 0x00, 0x00,
};

constexpr std::array<std::uint8_t, 92> kSimpleFunctionCall = {
    0x46, 0x52, 0x4F, 0x47, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x03, 0x69,
    0x6E, 0x63, 0x04, 0x00, 0x00, 0x00, 0x01, 0x61, 0x01, 0x00, 0x00, 0x00,
    0x05, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x02, 0x16, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x01,
    0x00, 0x00, 0x00, 0x01, 0x17, 0x00, 0x01, 0x02, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x03, 0x05, 0x00, 0x17, 0x00,
};

}

TEST(BytecodeVmTest, ConstantArithmeticChain) {
    BytecodeModule module = LoadModuleFromBytes(kConstantArithmeticChain);
    Vm vm(module, {});
    EXPECT_EQ(vm.run(), 0);
    ExpectGlobalInt(vm, "x", 70);
}

TEST(BytecodeVmTest, ConstantArithmeticPrecedence) {
    BytecodeModule module = LoadModuleFromBytes(kConstantArithmeticPrecedence);
    Vm vm(module, {});
    EXPECT_EQ(vm.run(), 0);
    ExpectGlobalInt(vm, "y", 14);
}

TEST(BytecodeVmTest, ConstantComparison) {
    BytecodeModule module = LoadModuleFromBytes(kConstantComparison);
    Vm vm(module, {});
    EXPECT_EQ(vm.run(), 0);
    ExpectGlobalBool(vm, "b", true);
}

TEST(BytecodeVmTest, ArrayLiteralLikeSequence) {
    BytecodeModule module = LoadModuleFromBytes(kArrayLiteral);
    Vm vm(module, {});
    EXPECT_EQ(vm.run(), 0);
    auto globals = vm.globals();
    auto it = globals.find("nums");
    ASSERT_NE(it, globals.end());
    ASSERT_EQ(it->second.tag, ValueTag::kArray);
    ArrayObject* arr = it->second.AsArray();
    ASSERT_EQ(arr->elements.size(), 3u);
    std::int64_t v0 = 0;
    std::int64_t v1 = 0;
    std::int64_t v2 = 0;
    ASSERT_TRUE(arr->elements[0].AsInt().TryToInt64(v0));
    ASSERT_TRUE(arr->elements[1].AsInt().TryToInt64(v1));
    ASSERT_TRUE(arr->elements[2].AsInt().TryToInt64(v2));
    EXPECT_EQ(v0, 3);
    EXPECT_EQ(v1, 3);
    EXPECT_EQ(v2, 4);
}

TEST(BytecodeVmTest, SimpleFunctionCall) {
    BytecodeModule module = LoadModuleFromBytes(kSimpleFunctionCall);
    Vm vm(module, {});
    EXPECT_EQ(vm.run(), 0);
    ExpectGlobalInt(vm, "a", 6);
}
